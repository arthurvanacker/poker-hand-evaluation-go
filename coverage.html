
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>poker-hand-evaluation: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/puupa/poker-hand-evaluation/card.go (96.4%)</option>
				
				<option value="file1">github.com/puupa/poker-hand-evaluation/deck.go (100.0%)</option>
				
				<option value="file2">github.com/puupa/poker-hand-evaluation/evaluator.go (91.7%)</option>
				
				<option value="file3">github.com/puupa/poker-hand-evaluation/hand.go (94.1%)</option>
				
				<option value="file4">github.com/puupa/poker-hand-evaluation/main.go (80.3%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "strings"
)

// Rank represents the rank of a playing card (2-14, where Ace=14)
type Rank int

// Rank constants with numeric values for easy comparison
const (
        Two   Rank = 2
        Three Rank = 3
        Four  Rank = 4
        Five  Rank = 5
        Six   Rank = 6
        Seven Rank = 7
        Eight Rank = 8
        Nine  Rank = 9
        Ten   Rank = 10
        Jack  Rank = 11
        Queen Rank = 12
        King  Rank = 13
        Ace   Rank = 14
)

// Suit represents the suit of a playing card
type Suit int

// Suit constants
const (
        Hearts Suit = iota
        Diamonds
        Clubs
        Spades
)

// Card represents a playing card with a rank and suit
type Card struct {
        Rank Rank
        Suit Suit
}

// String returns the string representation of a Rank (e.g., "A", "K", "Q", "J", "T", "9", ...)
func (r Rank) String() string <span class="cov8" title="1">{
        switch r </span>{
        case Ace:<span class="cov8" title="1">
                return "A"</span>
        case King:<span class="cov8" title="1">
                return "K"</span>
        case Queen:<span class="cov8" title="1">
                return "Q"</span>
        case Jack:<span class="cov8" title="1">
                return "J"</span>
        case Ten:<span class="cov8" title="1">
                return "T"</span>
        case Nine:<span class="cov8" title="1">
                return "9"</span>
        case Eight:<span class="cov8" title="1">
                return "8"</span>
        case Seven:<span class="cov8" title="1">
                return "7"</span>
        case Six:<span class="cov8" title="1">
                return "6"</span>
        case Five:<span class="cov8" title="1">
                return "5"</span>
        case Four:<span class="cov8" title="1">
                return "4"</span>
        case Three:<span class="cov8" title="1">
                return "3"</span>
        case Two:<span class="cov8" title="1">
                return "2"</span>
        default:<span class="cov0" title="0">
                return "?"</span>
        }
}

// String returns the string representation of a Suit (e.g., "h", "d", "c", "s")
func (s Suit) String() string <span class="cov8" title="1">{
        switch s </span>{
        case Hearts:<span class="cov8" title="1">
                return "h"</span>
        case Diamonds:<span class="cov8" title="1">
                return "d"</span>
        case Clubs:<span class="cov8" title="1">
                return "c"</span>
        case Spades:<span class="cov8" title="1">
                return "s"</span>
        default:<span class="cov0" title="0">
                return "?"</span>
        }
}

// String returns the card notation (e.g., "Ah" for Ace of Hearts)
func (c Card) String() string <span class="cov8" title="1">{
        return c.Rank.String() + c.Suit.String()
}</span>

// ParseCard parses a card string (e.g., "Ah", "Kd", "10s") into a Card struct.
// Accepts both "T" and "10" for Ten. Case-insensitive for suits.
func ParseCard(s string) (Card, error) <span class="cov8" title="1">{
        if len(s) &lt; 2 </span><span class="cov8" title="1">{
                return Card{}, fmt.Errorf("invalid card string: %q (too short)", s)
        }</span>

        <span class="cov8" title="1">var rankStr, suitStr string

        // Handle "10" notation for Ten
        if len(s) &gt;= 3 &amp;&amp; s[:2] == "10" </span><span class="cov8" title="1">{
                rankStr = "10"
                suitStr = s[2:]
        }</span> else<span class="cov8" title="1"> if len(s) == 2 </span><span class="cov8" title="1">{
                rankStr = s[:1]
                suitStr = s[1:]
        }</span> else<span class="cov8" title="1"> {
                return Card{}, fmt.Errorf("invalid card string: %q (invalid length)", s)
        }</span>

        // Parse rank
        <span class="cov8" title="1">var rank Rank
        switch strings.ToUpper(rankStr) </span>{
        case "A":<span class="cov8" title="1">
                rank = Ace</span>
        case "K":<span class="cov8" title="1">
                rank = King</span>
        case "Q":<span class="cov8" title="1">
                rank = Queen</span>
        case "J":<span class="cov8" title="1">
                rank = Jack</span>
        case "T", "10":<span class="cov8" title="1">
                rank = Ten</span>
        case "9":<span class="cov8" title="1">
                rank = Nine</span>
        case "8":<span class="cov8" title="1">
                rank = Eight</span>
        case "7":<span class="cov8" title="1">
                rank = Seven</span>
        case "6":<span class="cov8" title="1">
                rank = Six</span>
        case "5":<span class="cov8" title="1">
                rank = Five</span>
        case "4":<span class="cov8" title="1">
                rank = Four</span>
        case "3":<span class="cov8" title="1">
                rank = Three</span>
        case "2":<span class="cov8" title="1">
                rank = Two</span>
        default:<span class="cov8" title="1">
                return Card{}, fmt.Errorf("invalid rank: %q", rankStr)</span>
        }

        // Parse suit (case-insensitive)
        <span class="cov8" title="1">var suit Suit
        switch strings.ToLower(suitStr) </span>{
        case "h":<span class="cov8" title="1">
                suit = Hearts</span>
        case "d":<span class="cov8" title="1">
                suit = Diamonds</span>
        case "c":<span class="cov8" title="1">
                suit = Clubs</span>
        case "s":<span class="cov8" title="1">
                suit = Spades</span>
        default:<span class="cov8" title="1">
                return Card{}, fmt.Errorf("invalid suit: %q", suitStr)</span>
        }

        <span class="cov8" title="1">return Card{Rank: rank, Suit: suit}, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package main implements a Texas Hold'em poker hand evaluator
// that identifies the best 5-card hand from 5, 6, or 7 cards.
package main

import "fmt"

// Deck represents a collection of playing cards
type Deck struct {
        Cards []Card
}

// NewDeck creates and returns a new deck containing all 52 standard playing cards
func NewDeck() *Deck <span class="cov8" title="1">{
        deck := &amp;Deck{
                Cards: make([]Card, 0, 52),
        }

        // Generate all combinations of ranks and suits
        ranks := []Rank{Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten, Jack, Queen, King, Ace}
        suits := []Suit{Hearts, Diamonds, Clubs, Spades}

        for _, suit := range suits </span><span class="cov8" title="1">{
                for _, rank := range ranks </span><span class="cov8" title="1">{
                        deck.Cards = append(deck.Cards, Card{Rank: rank, Suit: suit})
                }</span>
        }

        <span class="cov8" title="1">return deck</span>
}

// Deal removes and returns the top n cards from the deck.
// Returns an error if n is greater than the number of available cards.
func (d *Deck) Deal(n int) ([]Card, error) <span class="cov8" title="1">{
        if n &gt; len(d.Cards) </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("cannot deal %d cards, only %d available", n, len(d.Cards))
        }</span>

        // Take n cards from the top of the deck
        <span class="cov8" title="1">dealt := d.Cards[:n]

        // Remove those cards from the deck
        d.Cards = d.Cards[n:]

        return dealt, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package main implements a Texas Hold'em poker hand evaluator
// that identifies the best 5-card hand from 5, 6, or 7 cards.
package main

// isFlush checks if all 5 cards are the same suit.
// Returns true if all cards share the same suit, false otherwise.
func isFlush(cards []Card) bool <span class="cov8" title="1">{
        if len(cards) != 5 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Use the first card's suit as reference
        <span class="cov8" title="1">firstSuit := cards[0].Suit

        // Check if all remaining cards match the first suit
        for i := 1; i &lt; len(cards); i++ </span><span class="cov8" title="1">{
                if cards[i].Suit != firstSuit </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// isStraight checks if 5 cards form a sequence.
// Returns (true, highRank) if cards form a straight, (false, 0) otherwise.
// Special case: wheel straight (A-2-3-4-5) returns (true, Five).
func isStraight(cards []Card) (bool, Rank) <span class="cov8" title="1">{
        if len(cards) != 5 </span><span class="cov0" title="0">{
                return false, 0
        }</span>

        // Extract and sort ranks in descending order
        <span class="cov8" title="1">ranks := make([]Rank, 5)
        for i, card := range cards </span><span class="cov8" title="1">{
                ranks[i] = card.Rank
        }</span>

        // Bubble sort descending (simple for 5 elements)
        <span class="cov8" title="1">for i := 0; i &lt; 5; i++ </span><span class="cov8" title="1">{
                for j := i + 1; j &lt; 5; j++ </span><span class="cov8" title="1">{
                        if ranks[i] &lt; ranks[j] </span><span class="cov8" title="1">{
                                ranks[i], ranks[j] = ranks[j], ranks[i]
                        }</span>
                }
        }

        // Check for wheel straight: A-2-3-4-5 (14-5-4-3-2 when sorted descending)
        <span class="cov8" title="1">if ranks[0] == Ace &amp;&amp; ranks[1] == Five &amp;&amp; ranks[2] == Four &amp;&amp; ranks[3] == Three &amp;&amp; ranks[4] == Two </span><span class="cov8" title="1">{
                return true, Five // Ace acts as low, high card is Five
        }</span>

        // Check for regular straight: each rank should be exactly 1 less than previous
        <span class="cov8" title="1">for i := 1; i &lt; 5; i++ </span><span class="cov8" title="1">{
                if ranks[i] != ranks[i-1]-1 </span><span class="cov8" title="1">{
                        return false, 0
                }</span>
        }

        // Regular straight found, highest rank is first element
        <span class="cov8" title="1">return true, ranks[0]</span>
}

// rankCounts counts how many cards of each rank exist in the hand.
// Returns a map where keys are Rank values and values are occurrence counts.
// Used for detecting pairs, trips, quads, and full houses.
func rankCounts(cards []Card) map[Rank]int <span class="cov8" title="1">{
        counts := make(map[Rank]int)

        for _, card := range cards </span><span class="cov8" title="1">{
                counts[card.Rank]++
        }</span>

        <span class="cov8" title="1">return counts</span>
}

// detectRoyalFlush checks if the given 5 cards form a royal flush.
// A royal flush is 10-J-Q-K-A all of the same suit.
// Returns true if the hand is a royal flush, false otherwise.
func detectRoyalFlush(cards []Card) bool <span class="cov8" title="1">{
        if len(cards) != 5 </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if all cards are the same suit
        <span class="cov8" title="1">if !isFlush(cards) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check for the exact ranks: 10, J, Q, K, A (Ten=10, Jack=11, Queen=12, King=13, Ace=14)
        <span class="cov8" title="1">requiredRanks := map[Rank]bool{
                Ten:   true,
                Jack:  true,
                Queen: true,
                King:  true,
                Ace:   true,
        }

        // Verify all required ranks are present
        for _, card := range cards </span><span class="cov8" title="1">{
                if !requiredRanks[card.Rank] </span><span class="cov8" title="1">{
                        return false
                }</span>
                // Remove the rank to ensure no duplicates
                <span class="cov8" title="1">delete(requiredRanks, card.Rank)</span>
        }

        // All required ranks should be consumed (map should be empty)
        <span class="cov8" title="1">return len(requiredRanks) == 0</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package main implements a Texas Hold'em poker hand evaluator
// that identifies the best 5-card hand from 5, 6, or 7 cards.
package main

import "fmt"

// HandCategory represents the category of a poker hand, ordered by strength.
// Higher values indicate stronger hands.
type HandCategory int

const (
        HighCard      HandCategory = 1  // No matching cards
        OnePair       HandCategory = 2  // Two cards of the same rank
        TwoPair       HandCategory = 3  // Two different pairs
        ThreeOfAKind  HandCategory = 4  // Three cards of the same rank
        Straight      HandCategory = 5  // Five cards in sequence
        Flush         HandCategory = 6  // Five cards of the same suit
        FullHouse     HandCategory = 7  // Three of a kind plus a pair
        FourOfAKind   HandCategory = 8  // Four cards of the same rank
        StraightFlush HandCategory = 9  // Straight with all cards the same suit
        RoyalFlush    HandCategory = 10 // Ace-high straight flush (10-J-Q-K-A)
)

// String returns the human-readable name of the hand category.
func (hc HandCategory) String() string <span class="cov8" title="1">{
        switch hc </span>{
        case HighCard:<span class="cov8" title="1">
                return "High Card"</span>
        case OnePair:<span class="cov8" title="1">
                return "One Pair"</span>
        case TwoPair:<span class="cov8" title="1">
                return "Two Pair"</span>
        case ThreeOfAKind:<span class="cov8" title="1">
                return "Three of a Kind"</span>
        case Straight:<span class="cov8" title="1">
                return "Straight"</span>
        case Flush:<span class="cov8" title="1">
                return "Flush"</span>
        case FullHouse:<span class="cov8" title="1">
                return "Full House"</span>
        case FourOfAKind:<span class="cov8" title="1">
                return "Four of a Kind"</span>
        case StraightFlush:<span class="cov8" title="1">
                return "Straight Flush"</span>
        case RoyalFlush:<span class="cov8" title="1">
                return "Royal Flush"</span>
        default:<span class="cov0" title="0">
                return "Unknown"</span>
        }
}

// Hand represents a poker hand with its cards, category, and tiebreakers.
// Tiebreakers are ranks in descending order of importance for comparing
// hands of the same category.
type Hand struct {
        Cards       []Card       // The 5 cards in the hand
        Category    HandCategory // The hand category (Royal Flush, etc.)
        Tiebreakers []Rank       // Ranks for tiebreaker comparison
}

// NewHand creates a new Hand from the given cards.
// Returns an error if the number of cards is not exactly 5.
func NewHand(cards []Card) (*Hand, error) <span class="cov8" title="1">{
        if len(cards) != 5 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("hand must contain exactly 5 cards, got %d", len(cards))
        }</span>

        // Create a copy of the cards slice to avoid external modification
        <span class="cov8" title="1">cardsCopy := make([]Card, 5)
        copy(cardsCopy, cards)

        return &amp;Hand{
                Cards:       cardsCopy,
                Category:    HighCard, // Default category, will be set by evaluator
                Tiebreakers: []Rank{}, // Will be populated by evaluator
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "fmt"
        "math/rand"
        "time"
)

func main() <span class="cov8" title="1">{
        // Seed the random number generator
        rand.Seed(time.Now().UnixNano())

        fmt.Println("=== Texas Hold'em Hand Evaluator Demo ===")
        fmt.Println()

        // Create a new deck
        deck := NewDeck()
        fmt.Printf("Created new deck with %d cards\n\n", len(deck.Cards))

        // Shuffle the deck
        shuffleDeck(deck)
        fmt.Println("Deck shuffled")
        fmt.Println()

        // Deal cards for Player 1
        player1Cards, err := deck.Deal(2)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error dealing cards: %v\n", err)
                return
        }</span>
        <span class="cov8" title="1">fmt.Printf("Player 1 hole cards: %s %s\n", player1Cards[0], player1Cards[1])

        // Deal cards for Player 2
        player2Cards, err := deck.Deal(2)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error dealing cards: %v\n", err)
                return
        }</span>
        <span class="cov8" title="1">fmt.Printf("Player 2 hole cards: %s %s\n\n", player2Cards[0], player2Cards[1])

        // Deal community cards (flop, turn, river)
        communityCards, err := deck.Deal(5)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error dealing community cards: %v\n", err)
                return
        }</span>
        <span class="cov8" title="1">fmt.Printf("Community cards: %s %s %s %s %s\n\n",
                communityCards[0], communityCards[1], communityCards[2],
                communityCards[3], communityCards[4])

        // Combine hole cards + community cards for each player
        player1Hand := make([]Card, 0, 7)
        player1Hand = append(player1Hand, player1Cards...)
        player1Hand = append(player1Hand, communityCards...)

        player2Hand := make([]Card, 0, 7)
        player2Hand = append(player2Hand, player2Cards...)
        player2Hand = append(player2Hand, communityCards...)

        fmt.Printf("Player 1's 7 cards: ")
        for _, card := range player1Hand </span><span class="cov8" title="1">{
                fmt.Printf("%s ", card)
        }</span>
        <span class="cov8" title="1">fmt.Println()

        fmt.Printf("Player 2's 7 cards: ")
        for _, card := range player2Hand </span><span class="cov8" title="1">{
                fmt.Printf("%s ", card)
        }</span>
        <span class="cov8" title="1">fmt.Println()
        fmt.Println()

        // Check for flushes
        fmt.Println("=== Hand Analysis ===")
        if isFlush(player1Hand[:5]) </span><span class="cov0" title="0">{
                fmt.Println("Player 1's first 5 cards form a FLUSH!")
        }</span>
        <span class="cov8" title="1">if isFlush(player2Hand[:5]) </span><span class="cov0" title="0">{
                fmt.Println("Player 2's first 5 cards form a FLUSH!")
        }</span>

        // Check for straights
        <span class="cov8" title="1">isStraightP1, highRankP1 := isStraight(player1Hand[:5])
        if isStraightP1 </span><span class="cov0" title="0">{
                fmt.Printf("Player 1's first 5 cards form a STRAIGHT (high: %s)!\n", highRankP1)
        }</span>

        <span class="cov8" title="1">isStraightP2, highRankP2 := isStraight(player2Hand[:5])
        if isStraightP2 </span><span class="cov0" title="0">{
                fmt.Printf("Player 2's first 5 cards form a STRAIGHT (high: %s)!\n", highRankP2)
        }</span>

        // Check for royal flushes
        <span class="cov8" title="1">if detectRoyalFlush(player1Hand[:5]) </span><span class="cov0" title="0">{
                fmt.Println("Player 1's first 5 cards form a ROYAL FLUSH!")
        }</span>
        <span class="cov8" title="1">if detectRoyalFlush(player2Hand[:5]) </span><span class="cov0" title="0">{
                fmt.Println("Player 2's first 5 cards form a ROYAL FLUSH!")
        }</span>

        // Display rank counts
        <span class="cov8" title="1">counts1 := rankCounts(player1Hand[:5])
        counts2 := rankCounts(player2Hand[:5])
        fmt.Printf("\nPlayer 1 rank distribution: %v\n", counts1)
        fmt.Printf("Player 2 rank distribution: %v\n", counts2)

        fmt.Printf("\nRemaining cards in deck: %d\n", len(deck.Cards))</span>
}

// shuffleDeck shuffles the deck using Fisher-Yates algorithm
func shuffleDeck(d *Deck) <span class="cov8" title="1">{
        for i := len(d.Cards) - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                j := rand.Intn(i + 1)
                d.Cards[i], d.Cards[j] = d.Cards[j], d.Cards[i]
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
